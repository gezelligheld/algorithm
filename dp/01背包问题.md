动态规划利用历史记录从而避免重复计算，是以空间换取时间的算法

以01背包问题为例，阐述一下动态规划的解题思路

问题：给一个可装载重量为w的背包和n个物品，每个物品有重量和价值两个属性，其中第i个物品的重量为wt[i]，价值为val[i]，那么这个背包能装的价值最多是多少

例如，有3个物品，n=3，背包容量w=4，wt=[ 2,1,3 ]，val=[ 4,2,3 ]，算法应返回6

1. 明确状态和选择

状态有两个：可选择的物品，背包的容量
选择有两个：装进背包、不装进背包

伪代码如下

```
for 状态1 in 状态1的所有取值
    for 状态2 in 状态2的所有取值
        dp[状态1][状态2] = 选择(选择1, 选择2)
```

2. 明确dp数组的定义

状态有两个，需要一个二维数组

那么dp[i][w]的定义为：对于前i个物品，当前背包容量为w，此时的物品最大价值

dp[0][w]：物品数量为0，价值为0

dp[i][0]：背包容量为0，价值为0

伪代码如下

```
// 加1是因为存在索引0
let dp[n + 1][w + 1]
dp[0][i] = 0
dp[i][0] = 0
for 状态1 in 状态1的所有取值
    for 状态2 in 状态2的所有取值
        dp[状态1][状态2] = 选择(选择1, 选择2)

return dp[n][w];
```

3. 状态转移方程

根据上面对dp[i][w]的定义，根据步骤1的选择分情况讨论

- 没有把第i个物品装进背包时，价值和上一次一致

dp[i][w] = dp[i - 1][w];

- 把第i个物品装进背包

由于有索引0，第i个物品的重量是wt[i - 1]，价值是val[i - 1]，则第i个物品装入后的价值=第i个物品的价值+之前的总价值

dp[i][w] = dp[i - 1][w - wt[i - 1]] + val[i - 1];

伪代码如下

```
let dp[n + 1][w + 1]
dp[0][i] = 0
dp[i][0] = 0
for i in [1, ..., n]
    for w in [1, ..., w]
        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - wt[i - 1]] + val[i - 1]);

return dp[n][w];
```

4. 将伪代码转换成代码

```js
// w 背包容量
// n 物品总数
// wt 物品重量数组
// val 物品价值数组
function knapsack(w, n, wt, val) {
    // 创建一个全是0的二维数组
    const dp = Array.from(new Array(n + 1), () => new Array(w + 1).fill(0));
    for (let i = 1; i <= n; i ++) {
        for (let j = 1; j <= w; j ++) {
            // 此时的容量装不下该物品，则价值是上一个的价值
            if (j - wt[i - 1] < 0) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = Math.max(
                    // 不装背包
                    dp[i - 1][j],
                    // 装背包
                    dp[i - 1][j - wt[i - 1]] + val[i - 1]
                )
            }
        }
    }
    return dp[n][w];
}

const W = 3;
const N = 4;
const wt = [2, 1, 3];
const val = [4, 2, 3];
knapsack(W, N, wt, val);
```