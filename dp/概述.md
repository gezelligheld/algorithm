动态规划是给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决，然后把子问题答案保存起来以减少重复计算，再根据子问题答案反推，得出原问题解的一种方法。其核心思想在于拆分子问题，记住过往，减少重复计算，是以空间换取时间的算法

#### 使用场景

如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等

#### 和其他算法的区别

- 动态规划和分治的区别：动态规划和分治都有最优子结构 ，但是分治的子问题不重叠

- 动态规划和贪心的区别：动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优解，所以它永远是局部最优，但是全局的解不一定是最优的

- 动态规划和递归的区别：递归和回溯可能存在非常多的重复计算，动态规划可以用递归加记忆化的方式减少不必要的重复计算

#### 解题思路

以 01 背包问题为例，阐述一下动态规划的解题思路

问题：给一个可装载重量为 w 的背包和 n 个物品，每个物品有重量和价值两个属性，其中第 i 个物品的重量为 wt[i]，价值为 val[i]，那么这个背包能装的价值最多是多少？例如，有 3 个物品，n=3，背包容量 w=4，wt=[ 2,1,3 ]，val=[ 4,2,3 ]，算法应返回 6

##### 定义子问题

最终的问题是求背包能装的最大价值，拆解一下就是，前 i 个物品重量为 w 的最大价值。动态规划实际上通过一堆子问题的解求出原问题的解，子问题满足以下两点

- 原问题可以由子问题表示，当 i = n 时就是问题的解
- 一个子问题的解要能通过其他子问题的解求出

##### 子问题递推关系

前 i 个物品重量为 w 的价值的推导有两种情况。前 i-1 个物品重量为 w-1 的价值，如果加上第 i 个超过了背包的容量，则第 i 个物品的价值和前 i-1 个物品的价值就是一样的，否则加上第 i 个物品的价值

##### 确定状态转移方程

如下，其中第 i 个物品的重量是 wt[i - 1]，价值是 val[i - 1]

```bash
# 情况1
dp[i][w] = dp[i - 1][w - 1]
# 情况2
dp[i][w] = dp[i - 1][w - wt[i - 1]] + val[i - 1]
```

还需要考虑边界情况

```bash
# 物品数量为0，价值为0
dp[0][w] = 0
# 背包容量为0，价值为0
dp[i][0] = 0
```

##### 实现

```js
function knapsack(w, n, wt, val) {
  const dp = Array.from(new Array(n), () => new Array(w).fill(0));
  for (let i = 1; i < n; i++) {
    for (let j = 1; j < w; j++) {
      // 当前容量不足以容纳第i个物品
      if (j - wt[i - 1] < 0) {
        dp[i][j] = dp[i - 1][j];
      } else {
        dp[i][j] = Math.max(
          dp[i - 1][j],
          dp[i - 1][w - wt[j - 1]] + val[i - 1]
        );
      }
    }
  }
  return dp[n][w];
}
```
