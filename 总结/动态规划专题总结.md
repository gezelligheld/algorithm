动态规划利用历史记录从而避免重复计算，是以空间换取时间的算法

以 01 背包问题为例，阐述一下动态规划的解题思路

问题：给一个可装载重量为 w 的背包和 n 个物品，每个物品有重量和价值两个属性，其中第 i 个物品的重量为 wt[i]，价值为 val[i]，那么这个背包能装的价值最多是多少

例如，有 3 个物品，n=3，背包容量 w=4，wt=[ 2,1,3 ]，val=[ 4,2,3 ]，算法应返回 6

1. 明确状态和选择

状态有两个：可选择的物品，背包的容量
选择有两个：装进背包、不装进背包

伪代码如下

```
for 状态1 in 状态1的所有取值
    for 状态2 in 状态2的所有取值
        dp[状态1][状态2] = 选择(选择1, 选择2)
```

2. 明确 dp 数组的定义和边界条件

状态有两个，需要一个二维数组

那么 dp[i][w]的定义为：对于前 i 个物品，当前背包容量为 w，此时的物品最大价值

dp[0][w]：物品数量为 0，价值为 0

dp[i][0]：背包容量为 0，价值为 0

伪代码如下

```
// 加1是因为存在索引0
let dp[n + 1][w + 1]
dp[0][i] = 0
dp[i][0] = 0
for 状态1 in 状态1的所有取值
    for 状态2 in 状态2的所有取值
        dp[状态1][状态2] = 选择(选择1, 选择2)

return dp[n][w];
```

3. 状态转移方程

根据上面对 dp[i][w]的定义，根据步骤 1 的选择分情况讨论

- 没有把第 i 个物品装进背包时，价值和上一次一致

dp[i][w] = dp[i - 1][w];

- 把第 i 个物品装进背包

由于有索引 0，第 i 个物品的重量是 wt[i - 1]，价值是 val[i - 1]，则第 i 个物品装入后的价值=第 i 个物品的价值+之前的总价值

dp[i][w] = dp[i - 1]w - wt[i - 1]] + val[i - 1];

伪代码如下

```
let dp[n + 1][w + 1]
dp[0][i] = 0
dp[i][0] = 0
for i in [1, ..., n]
    for w in [1, ..., w]
        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - wt[i - 1]] + val[i - 1]);

return dp[n][w];
```

4. 将伪代码转换成代码

```js
// w 背包容量
// n 物品总数
// wt 物品重量数组
// val 物品价值数组
function knapsack(w, n, wt, val) {
  // 创建一个全是0的二维数组
  const dp = Array.from(new Array(n + 1), () => new Array(w + 1).fill(0));
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= w; j++) {
      // 此时的容量装不下该物品，则价值是上一个的价值
      if (j - wt[i - 1] < 0) {
        dp[i][j] = dp[i - 1][j];
      } else {
        dp[i][j] = Math.max(
          // 不装背包
          dp[i - 1][j],
          // 装背包
          dp[i - 1][j - wt[i - 1]] + val[i - 1]
        );
      }
    }
  }
  return dp[n][w];
}

const W = 3;
const N = 4;
const wt = [2, 1, 3];
const val = [4, 2, 3];
knapsack(W, N, wt, val);
```
