给定一个二叉树，返回它的 后序 遍历

后序遍历：按照访问左子树——右子树——根节点的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树

方法一：递归

```js
function postorderTraversal(root) {
    const res = [];
    const postorder = root => {
        if (!root) {
            return;
        }
        postorder(root.left);
        postorder(root.right);
        res.push(root.val);
    };
    postorder(root);
    return res;
}
```

方法二：深度优先搜索

```js
function postorderTraversal(root) {
    const res = [];
    const stack = [];
    let prev = null;
    while (root || stack.length) {
        while (root) {
        stack.push(root);
        root = root.left;
    }
    root = stack[stack.length - 1];
    // 当由子树存在且未访问过时，继续遍历
    // 需要限制未访问的原因是，最后遍历当前子树的根节点时会重复访问到右子树
    if (root.right && root.right !== prev) {
        root = root.right;
    } else {
        stack.pop();
        res.push(root.val);
        prev = root;
    }
  }
};
```