对每一个可能的分支路径深入到不能再深入为止，用递归或栈实现

```
    3
   / \
  9  20
    /  \
   15   7
```

深度优先遍历输出：3,9,20,15,7

- 先序遍历

输出：3，9，20，15，7（根节点 + 左子树先序遍历 + 右字数先序遍历）

```js
// 递归
function preOrder(node, arr) {
    if (node) {
        arr.push(node.val);
        preOrder(node.left);
        preOrder(node.right);
    }
    return arr;
}

// 栈
function preOrder(node) {
    const res = [];
    const stack = [];
    let cur = node;
    while (cur || stack.length > 0) {
        while (cur) {
            res.push(cur.val);
            // 左子树入栈
            stack.push(cur);
            cur = cur.left;
        }
        // 栈后入先出，依次回溯
        cur = stack.pop();
        // 再遍历右子树
        cur = cur.right;
    }
    return res;
}
```

- 中序遍历

输出：9，3，15，20，7（左子树中序遍历 + 根节点 + 右字数中序遍历）

```js
// 递归
function inOrder(node, arr) {
    if (node) {
        inOrder(node.left);
        arr.push(node.val);
        inOrder(node.right);
    }
    return arr;
}

// 栈
function inOrder(node) {
    const res = [];
    const stack = [];
    let cur = node;
    while (cur || stack.length > 0) {
        while (cur) {
            // 左子树入栈
            stack.push(cur);
            cur = cur.left;
        }
        // 栈后入先出，依次回溯
        cur = stack.pop();
        res.push(cur.val);
        // 再遍历右子树
        cur = cur.right;
    }
    return arr;
}
```

- 后序遍历

输出：9，15，7，20，3（左子树后序遍历 + 右子树后序遍历 + 根节点）

```js
// 递归
function nextOrder(node, arr) {
    if (node) {
        nextOrder(node.left);
        nextOrder(node.right);
        arr.push(node.val);
    }
    return arr;
}

// 栈
function nextOrder(node) {
    const res = [];
    const stack = [];
    let cur = node;
    while (cur || stack.length > 0) {
        while (cur) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack[stack.length - 1];
        if (!cur.right) {
            cur = stack.pop();
            res.push(cur.val);
            cur = null;
        }
        else {
            cur = cur.right;
        }
    }
}
```