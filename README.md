# algorithm

- binarySearch 二分查找
- linkedList 链表相关问题
- binaryTree 二叉树相关问题
- dp 动态规划
- backtrack 回溯
- stack-queue 栈&队列
- doublePointer 双指针问题
- sort 排序
- 贪心
- 分治
- 哈希表

#### 时间复杂度和空间复杂度

##### 时间复杂度

算法的时间复杂度反映了程序运行从开始到结束所需要的时间，常见的时间复杂度如下

- 常数复杂度 O(1)，没有循环语句
- 对数复杂度 O(log n)
- 线性时间复杂度 O(n)，即一重循环
- 平方 O(n^2)
- 立方 O(n^3)
- 指数 O(2^n)
- 阶乘 O(n!)

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/20/16cac3540b752726~tplv-t2oaga2asx-watermark.awebp)

##### 空间复杂度

算法的空间复杂度是指运行完一个程序所需内存的大小

> 算法的返回值不计入空间复杂度

#### 数据结构

##### 逻辑结构

逻辑结构表征数据间的关系

- 线性结构，有序数据元素的集合，元素间的关系一一对应
- 非线性结构，每个数据元素可能与零个或者多个其他数据元素发生联系

##### 存储结构

- 顺序存储，如数组，在内存中的位置是连续的
- 链式存储，如链表，是主动建立数据间的关联关系的，在内存中却不一定是连续的
- 散列存储，如哈希表，顺序和逻辑上都不存在顺序关系，但是你可以通过一定的方式去访问它

##### 数组

每个元素都可以通过数组索引来找到，插入和删除时要移动后续元素，效率较差

##### 栈

用来限制数据的访问顺序，栈内的元素只能通过列表的一端访问，只能在栈顶添加或删除元素，后入先出

##### 队列

用来限制数据的访问顺序，只能在队尾插入元素，队首删除元素，先入先出

##### 链表

用一组任意存储的单元来存储线性表的数据元素，一个对象存储着本身的值和其他元素的地址。需要遍历才能查询到元素，查询慢，但插入和删除元素的效率较高

- 单向链表：每个节点使用一个对象的引用指向下一个元素
- 双向链表：每个节点使用对象的引用指向下一个元素和上一个元素
- 循环链表：尾节点指向头节点

##### 集合

集合中的成员是无序的，且不允许相同成员存在，如 Set

##### 字典

一种以键值对形式存储数据的数据结构

##### 哈希表

哈希的基本原理是将给定的键值转换为偏移地址来检索记录，键转换为地址是通过某种关系来完成的，这就是哈希（散列）函数。插入和删除的效率高，查找的效率低

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/20/16cac3543f8bb37c~tplv-t2oaga2asx-watermark.awebp)

当两个不同的关键字，由于哈希函数值相同，因而被映射到同一表位置上。该现象称为冲突或碰撞，解决方式一般有以下几种

- 开放地址法：发生碰撞时，检查散列表中的下一个位置是否为空，如果为空就存入，否则继续检查下一个位置，直到找到空位置，具体要寻找哪一个位置插入又有以下三种方法
  - 线性探测，每次以步长为 1 寻找空位置，直到找到为止
  - 二次探测：优化了探测时的步长，如从冲突位置 x 开始，依次探索 x+1，x+2^2，x+3^2...，这样可以一次探测较长的距离，减少了散列表中元素聚集带来探测多次的影响
  - 再哈希法：通过另一个哈希函数再做一次哈希化，结果作为步长
- 开链法：实现散列表的底层数组中，每个元素是一个新的数据结构（数组或链表），来存储多个键，冲突时放入此位置下不同的位置上即可

##### 二叉树

以分层的方式存储数据，查找、添加、删除元素效率高，每个节点的子节点不超过两个

- 对称二叉树：根节点的左右子树左右镜像对称

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

- 平衡二叉树：二叉树中任意节点的左右子树的深度相差不超过 1

```
    3
   / \
  9  20
    /  \
   15   7
```

- 二叉搜索树：节点的左子树只包含小于当前节点的数，节点的右子树只包含大于当前节点的数，所有左子树和右子树自身必须也是二叉搜索树

```
    2
   / \
  1   3
```

#### 算法

##### 排序

常见排序算法如下

- 冒泡排序：依次比较两个值的大小，如果逆序，交换这两个值的位置
- 快速排序：取中间索引的值作为基准，将小于和大于这个基准的键值分成两个部分，然后再分别快速排序，依次类推
- 选择排序：默认记录一个最小值，如果第 i 个值比最小的值还要小，则交换位置
- 插入排序：构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
- 归并排序：将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列

##### 二分查找

在一个区间内比较中间位置的元素和目标元素的大小，进而决定目标值落到那个分区。对有序数组进行查找时，优先考虑二分查找

##### 递归

函数调用自身，需要一个终止条件

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/20/16cac35473048a81~tplv-t2oaga2asx-watermark.awebp)

##### 广度优先搜索

越是接近根结点的结点将越早被遍历，一般使用队列实现

##### 深度优先搜索

更早访问的结点可能不是更靠近根结点的结点，一般用栈实现。深度优先和广度优先对比如下

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/20/16cac3549dee7c41~tplv-t2oaga2asx-watermark.awebp)

##### 回溯算法

采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案，采用递归实现

##### 动态规划

动态规划本质上是穷举，利用历史记录从而避免重复计算，是以空间换取时间的算法

##### 贪心算法

对问题求解的时候，总是做出在当前看来是最好的做法
